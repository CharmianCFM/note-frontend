### 1 说说你对低代码的理解
低代码开发平台，英文全称“Low-Code Development Platform”，简称 LCDP，是通过少量代码或零代码就可以快速生成新应用，实现业务应用的快速交付的应用平台。广义上的低代码平台包括低代码和零代码，它们都属于 APaaS（应用平台即服务）。
低代码平台代替了程序员开发数千行具有复杂代码和语法的行。它的作用是让开发人员以及业务人员，通过“拖拉拽”的方式使用平台，来创建完整的应用程序。同时突破了传统业务之间沟通的复杂度和交付时间周期长的特点，能够持续进行开发。
**低代码、无代码**
低代码平台包括低代码和无代码，二者区别如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710606584503-985ef203-3719-43f2-9470-a87be634e38f.png#averageHue=%23dbdcd8&clientId=u87eb2971-fcda-4&from=paste&height=255&id=u3e99a142&originHeight=510&originWidth=1177&originalType=binary&ratio=2&rotation=0&showTitle=false&size=23246&status=done&style=none&taskId=ub5a86a4a-9f60-4191-b8ed-7d3d142469e&title=&width=588.5)

- 无代码：主要面向业务人员，零开发经验的业务人员通过拖拽等方式，无需编写代码，即可快速搭建各种应用。无代码更适合单点场景的应用，平台应用性高于低代码。
- 低代码：主要面向开发人员，通过自动代码生成和可视化编程，只需要少量代码，即可快速搭建各种应用。低代码的市场占有率高，适合复杂场景交互应用的搭建。平台灵活性高于无代码。

但本质上低代码与无代码都能够降低开发门槛、快速响应业务需求、提升开发效率。
**低代码平台的技术路线**
因低代码平台源自于集成开发环境（Integrated Development Environment，IDE）的可视化、模块化与集成化特点，同时根据目标人群对象的使用，大体分为两条线路：第一条为业务复用型，主要包含应用开发平台、智能表格、SAAS 聚合，特点是数据与逻辑完全分离、各自独立的模型驱动，适合开发人员。第二条为开发工具型，主要包含在线 IDE、DSL 开发框架、组件代码库，特点是数据与储存结构合一的表单驱动，适合业务人员使用。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710606386389-8a74440f-0c60-4c9e-bdab-2cc8c634ab27.png#averageHue=%236ecaf9&clientId=u87eb2971-fcda-4&from=paste&height=153&id=ub330c1f6&originHeight=305&originWidth=917&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10490&status=done&style=none&taskId=u592edac9-e7c3-4b6c-8dce-6b47a5ae5ec&title=&width=458.5)
**适合开发人员的技术路线**
我们首先来看下适用于开发人员的技术路线模型驱动。由模型驱动对软件所涉及到的功能进行建模，然后以应用开发平台为核心，承载各种开发工具和复杂逻辑，并将其可视化。然后辅以少量代码，就能够作为技术中台核心帮助开发者快速产出一整套系符合企业需求的系统。具体处理场景示例如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710605818085-1031b495-fc02-46c2-9457-ab00a5a3d36d.png#averageHue=%238b9599&clientId=u87eb2971-fcda-4&from=paste&height=336&id=aTrkx&originHeight=671&originWidth=1199&originalType=binary&ratio=2&rotation=0&showTitle=false&size=24104&status=done&style=none&taskId=u502dd728-c2a0-47fc-8522-9f491e822ce&title=&width=599.5)
开发人员通过图中左右两边进行操作，左边是一些特定组件，拖到中间的画布里面。图中的板块都是相互独立的，需要通过右边的语法把它们进行关联，再生成所需要的场景化应用，这是模型驱动的一种方式。
**适合业务人员的技术路线**
该路线是非IT模式，以表单驱动数据为核心，通过拖拽构建数据表方式展开业务分析设计。以做到完全去IDE化，像搭积木一样按流程构建程序逻辑。适合完全零基础人员，比如人事行政进行资料归档、OA审批，销售人员客户管理等。
处理场景示例如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710604983271-a5240297-2b0d-4f99-b7ad-88b971b3afa9.png#averageHue=%23fafbf8&clientId=u87eb2971-fcda-4&from=paste&height=316&id=u99a1908b&originHeight=631&originWidth=1266&originalType=binary&ratio=2&rotation=0&showTitle=false&size=17092&status=done&style=none&taskId=u025e123f-673f-4daa-8ac0-980aba3dfa5&title=&width=633)
左边是拖拽组件，中间是画布，右边是编辑属性。我们通过左边拖拽表单将事件排列在上面，进行简单的数据收集。右边是对表单进行数据处理，比如标题、宽度、必填线等设置。适合业务人员去操作填写数据表格，快速生成自己想要的数据收集，这是表单驱动的一种方式。
对于这类技术路线的产品，又拍云在2020年曾经开发过一套，我们接下来通过又拍云低代码产品来看一下表单驱动的具体应用场景。
**低代码可视化拖拽平台的应用**
该产品使用拖拉拽的方式，生成所需要的表单。生成表单后，显示面板会把表单数组包括的 json 数据拿出，再通过它识别组件的顺序进行编译后展示。产品页面结构如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710604933739-bba819e0-6ddc-46d3-98eb-78dc09126e88.png#averageHue=%23fbf8f7&clientId=u87eb2971-fcda-4&from=paste&height=327&id=u3ced33f5&originHeight=653&originWidth=1280&originalType=binary&ratio=2&rotation=0&showTitle=false&size=16280&status=done&style=none&taskId=u287ee8d4-12f6-4139-865e-160a810d4b9&title=&width=640)
**编辑器实现思路**
该产品的编辑器实现思路如下：
首先，使用数组 componentData 维护编辑器中的数据。
其次，将组件通过拖拽事件，拖拽到画布上进行移动布局。当然一个组件要设为可拖拽，那就需要为它添加 draggable 属性，而且在将组件列表中的组件拖拽到画布中时还会经历两个关键事件：

- dragstart 事件
- drop 事件

**dragstart 事件**，它在拖拽刚开始时触发，主要用于将拖拽的组件信息传递给画布
**drop 事件**，在拖拽结束时触发，主要作用是用于接收拖拽的组件信息
之后使用 push() 方法将新的组件数据添加到 componentData。比如又拍云使用的 VLE 框架就是通过属性来识别我们想要的组件。具体为组件 V-item 是文本数据宽，可以通过其对应的属性值进行上下数据绑定，把数据填到结成数组里面。
组件数据如下：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710605298032-8c525b2a-1b51-4bee-8b75-6c0d4ce43f7f.png#averageHue=%23f3f3f3&clientId=u87eb2971-fcda-4&from=paste&height=360&id=ucc00c645&originHeight=720&originWidth=800&originalType=binary&ratio=2&rotation=0&showTitle=false&size=24150&status=done&style=none&taskId=u78cd89f8-301b-47b9-be4d-e0e2cb169e6&title=&width=400)
最后，我们使用 v-for 指令遍历 componentData，主要通过 is 属性来识别出真正要渲染的是哪个组件，将每个组件逐个渲染到画布。例如要渲染的组件数据是 { component: 'v-text' }，则  会被转换为 。
编辑器渲染的核心代码如下所示：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710605341132-ca74e523-f957-4550-8b24-07128f0d4ac8.png#averageHue=%23f9f7f5&clientId=u87eb2971-fcda-4&from=paste&height=182&id=u989b56d4&originHeight=364&originWidth=638&originalType=binary&ratio=2&rotation=0&showTitle=false&size=13882&status=done&style=none&taskId=u9c661b67-d385-4ac2-bd6b-620965c6e5b&title=&width=319)
全部完成后我们来看一下整体，如果将画布设为相对定位 position: relative，然后将每个组件设为绝对定位 position: absolute，只要通过监听三个事件就可以进行移动，这三个事件分别为：

- Mousedown 事件，在组件上按下鼠标时，记录组件当前的位置，即 css 中的 left 和 top。
- Mousemove 事件，每次鼠标移动时，都用当前最新的 left 和 top 减去最开始的 left 和 top，从而计算出移动距离，再改变组件位置。
- Mouseup 事件，鼠标抬起时结束移动。

以上就是编译器的整体实现思路。
**浅谈低代码平台的未来**
根据咨询机构 Gartner 的市场分析来看，2023 年全球超过 50% 的大中型企业将把低代码应用平台作为主要的占领应用平台之一。预计到2024年，低代码应用程序开发将占总应用开发的65%以上。这就引出了两个问题：传统的软件开发会被取代吗？低代码是未来的趋势吗？
实际上，低代码开发并不会取代传统的软件开发，但**它将改变在某些领域中的软件开发，改变那些重复低效的业务**，这意味着公司不需要为这种业务招聘大量的开发人员，而是安排更多的专业软件开发人员面向客户的需求以及复杂和独特的软件开发问题。
尽管相较于原生的开发模式，**低代码开发平台能够显著提升开发效率，尤其适合业务变化快、预算有限、开发时间紧迫的企业应用场景**；但是低代码平台也有明显的局限性，至少就目前来说，**它主要用于搭建企业软件。因为此类软件架构是有一定规律的**，但娱乐、社交等软件开发比较深层交互的东西低代码还是无法实现的。
### 2 如何检查 js中的内存泄露
JavaScript 中的内存泄漏通常发生在不再需要的对象仍然被引用，而垃圾回收器无法回收它们的情况下。以下是一些常见的检查 JavaScript 内存泄漏的方法：

1. **使用浏览器开发者工具：** 现代的浏览器开发者工具提供了 Memory 面板，可以帮助你监视 JavaScript 内存使用情况。你可以在这里看到内存的增长情况、内存快照以及跟踪对象的引用关系。
2. **检查闭包：** 在 JavaScript 中，闭包是一个常见的内存泄漏来源。确保在不需要时释放闭包的引用是重要的。特别是在事件处理程序和定时器中使用闭包时要格外小心。
3. **手动解除事件绑定：** 当你绑定事件处理程序时，如果不手动解除这些绑定，可能会导致内存泄漏。确保在不再需要时解除所有事件绑定，可以通过 **removeEventListener** 方法来完成。
4. **避免循环引用：** 当对象之间存在循环引用时，垃圾回收器可能无法正确识别并回收这些对象，从而导致内存泄漏。确保避免在对象之间创建循环引用。
5. **使用内存泄漏检测工具：** 一些第三方工具和库可以帮助你检测 JavaScript 中的内存泄漏，如 Chrome DevTools、Heap.js 等。这些工具可以帮助你识别潜在的内存泄漏问题，并提供更深入的分析和解决方案。
6. **注意 DOM 元素的引用：** 如果你在 JavaScript 中频繁操作 DOM 元素，并且没有及时释放对这些元素的引用，可能会导致内存泄漏。确保及时释放对不再需要的 DOM 元素的引用。
7. **使用内存快照：** 浏览器开发者工具通常提供内存快照功能，可以帮助你比较不同时间点的内存使用情况，并识别潜在的内存泄漏问题。
> **浏览器**
> Chrome 浏览器查看内存占用，按照以下步骤操作。
> 1、打开开发者工具，选择 Performance 面板
2、在顶部的Capture字段里面勾选 Memory
3、点击左上角的录制按钮。
4、在页面上进行各种操作，模拟用户的使用情况。
5、一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。
> ![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710664691447-fbfefe49-cc0a-4b6a-93d1-e2f1acb619e9.png#averageHue=%23f9f8fa&clientId=u87eb2971-fcda-4&from=paste&height=157&id=ucb627da9&originHeight=313&originWidth=720&originalType=binary&ratio=2&rotation=0&showTitle=false&size=27000&status=done&style=none&taskId=ua18c1de4-eae5-4439-8272-c52ca9d1f6d&title=&width=360)
> 如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。反之就是泄露了。
> **命令行**
> 命令行可以使用 Node 提供的process.memoryUsage方法。
> console.log(process.memoryUsage());
// { rss: 27709440,
// heapTotal: 5685248,
// heapUsed: 3449392,
// external: 8772 }
> process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。
> rss（resident set size）：所有内存占用，包括指令区和堆栈。
heapTotal："堆"占用的内存，包括用到的和没用到的。
heapUsed：用到的堆的部分。
external： V8 引擎内部的 C++ 对象占用的内存。
> 判断内存泄漏，以 heapUsed 字段为准。

### 3 说说你对跨平台的理解
我们知道，cpu 有不同的架构和指令集，上层也有不同的操作系统，一个系统的可执行文件在另一个系统上就是不可执行的，比如 windows 的 exe 文件在 mac 上就不能直接执行。不同的系统就是不同的运行平台。可执行文件是不跨平台的。
不同平台提供的 api 不同，所以代码逻辑可能也不同，需要不同平台单独维护代码。这样就带来了几个问题：

- 多平台各自开发，怎么保证功能是一致的
- 多平台各自开发，那是不是得各自测试，开发和测试的人力都是多份的

所以出现了跨平台的一些技术，目标是一份代码跑在任意平台。
我们先来看一些各领域的跨平台方案：
**浏览器**
操作系统不同，浏览器上跑的网页的代码确实同一份。浏览器就是一种历史悠久的跨平台方案。
网页跨平台不意味着浏览器也是跨平台的，浏览器的可执行文件还是每个平台单独开发和编译的，但是他们支持的网页解析逻辑一样，这样上面跑的网页就是跨平台的。
浏览器提供了一个容器，屏蔽了底层差异，提供了统一的 api（dom api），这样就可以实现同一份代码跑在不同平台的统一的容器里。这个容器叫做浏览器引擎，由 js 引擎、渲染引擎等构成。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710666321816-8cbf375d-82a8-4356-9ff5-79294a91501d.png#averageHue=%23f0f7fd&clientId=u87eb2971-fcda-4&from=paste&height=463&id=ub1227279&originHeight=926&originWidth=1656&originalType=binary&ratio=2&rotation=0&showTitle=false&size=62320&status=done&style=none&taskId=ub72a16da-c77f-4ad7-ac6c-fd4b2c8e8a2&title=&width=828)
**docker**
docker 是一种虚拟化技术，可以在操作系统之上加一个虚拟层，在这层之上划分一到多个容器，容器里再去跑系统、app，这样可以实现硬件和软件的分离，动态分配硬件资源给容器，并且方便 app 运行环境的整体迁移（保存成镜像）。![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710666405576-a85c10e9-878f-4069-af12-882802eff261.png#averageHue=%23b2ada4&clientId=u87eb2971-fcda-4&from=paste&height=351&id=uf1e92276&originHeight=702&originWidth=1270&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42519&status=done&style=none&taskId=u3768686f-5013-4119-8bb2-cdb5096120c&title=&width=635)
docker 很明显也是一种跨平台技术，同一个镜像可以跑在任何操作系统的 docker 上。只要不同操作系统实现同样的容器即可。
**jvm**
java 是一门编译 + 解释的语言，java 源码编译成字节码，然后字节码直接在 vm 上解释执行。
java 为什么这么火呢？主要是因为跨平台。
c、c++ 这种语言写的代码需要编译成不同操作系统上的可执行文件来跑，而且每个平台的代码可能还不一样，需要写多份。
java 因为提供了 jvm 容器，只要把源码编译成 jvm 能解释的字节码就行了，而且 jdk 提供了统一的 api，分别由不同操作系统的底层 api 来实现，这样对于 java 代码来说，不同操作系统的代码是一致的。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710666690986-72434ae3-d6b2-4019-a701-f57f9041be76.png#averageHue=%23b3aea6&clientId=u87eb2971-fcda-4&from=paste&height=369&id=QQY4i&originHeight=738&originWidth=1340&originalType=binary&ratio=2&rotation=0&showTitle=false&size=40803&status=done&style=none&taskId=u8c293b84-135a-4655-bb06-da05f5481a9&title=&width=670)
jvm 也是通过容器的技术实现了一份代码跑在多个平台，而且 jre 提供了统一的 api，屏蔽掉了底层的差异。
**node、deno**
node 和 deno 也是跨平台的技术，通过提供一套一致的 api，让其上的 js 代码可以跨平台。这些 api 也是不同平台各自实现的。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710666778852-c2d5ea09-99f7-4694-9d9e-8421eb9f7d0d.png#averageHue=%23b7b2aa&clientId=u87eb2971-fcda-4&from=paste&height=351&id=u71fa121e&originHeight=702&originWidth=1388&originalType=binary&ratio=2&rotation=0&showTitle=false&size=45530&status=done&style=none&taskId=u265999f3-bcf6-4aef-929d-53b37d00331&title=&width=694)
**electron**
 Electron 是一个基于 Web 技术的跨平台桌面应用开发框架，使用 HTML、CSS 和 JavaScript 编写。它使用了 Chromium 和 Node.js 来打包 Web 应用成原生桌面应用，可以在 Windows、macOS 和 Linux 平台上运行。Electron 提供了丰富的 API 和插件，可以实现与原生应用相似的功能和性能。
electron 内置了 chromium，并为其注入了 node 的 api 和一些 GUI 相关的 api，是基于两大跨平台技术综合而成的跨平台方案。基于这些方案的组合使得 electron 支持用前端技术开发桌面端。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710666927693-a7ff2831-31c9-4a11-b0e7-3515c47aae43.png#averageHue=%23b4aea3&clientId=u87eb2971-fcda-4&from=paste&height=354&id=u7e72ba60&originHeight=708&originWidth=1374&originalType=binary&ratio=2&rotation=0&showTitle=false&size=54527&status=done&style=none&taskId=u7eadafe6-7bf4-4c5e-8ab5-6eee74a6baf&title=&width=687)
**跨平台方案的优缺点**
跨平台方案的优点很明显，就是一份代码跑在不同平台的同样的容器内，不用不同平台单独开发，节省成本。
但是跨平台方案也有缺点：

- 因为多了一层容器，所以性能相比直接调用系统 api 会有所下降
- 为了实现多平台的一致，需要提供一套统一的 api，这套 api 有两个难题：
   - api 怎么设计。要综合不同平台的能力，取一个合适的集合来实现。设计上有一定难度。node、deno、java 都抽象了操作系统的能力，提供了各自的跨平台 api
   - 部分 api 很难做到多平台的一致性
   - 当容器没有提供的能力需要扩展的时候比较麻烦，比如 js 引擎的 bridge、 jvm 的 jni、node 的 c++ addon 等都是为这个容器扩展能力的方式
### 4 前端领域有哪些跨端方案
跨平台指的是跨操作系统，而跨端是指客户端。
客户端的特点就是有界面、有逻辑，所以包含逻辑跨端和渲染跨端。主要的客户端有 web、安卓、ios、iot 设备等。
现在主流的跨端方案有 react native、weex、flutter、kraken 以及各家自研的跨端引擎等。
**react native**
跨端包括逻辑跨端和渲染跨端，rn 的逻辑跨端是基于 js 引擎，通过 bridge 注入一些设备能力的 api，而渲染跨端则是使用安卓、ios 实现 react 的 virtual dom 的渲染。
 React Native 是由 Facebook 推出的一种基于 React 的跨平台移动应用开发框架。它允许开发者使用 JavaScript 和 React 构建原生移动应用，并在 iOS 和 Android 平台上运行。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710667418889-36317353-5dcc-4eec-b224-d54dd7beae8f.png#averageHue=%23e0e7eb&clientId=u87eb2971-fcda-4&from=paste&height=437&id=u67c00cd5&originHeight=874&originWidth=1302&originalType=binary&ratio=2&rotation=0&showTitle=false&size=56182&status=done&style=none&taskId=u617f9006-aeb2-4a05-99eb-177eebf7769&title=&width=651)
其中 native api 和组件（灰色画出的部分）并没有做到双端一致，而且有的时候扩展图中灰色部分需要原生配合，混杂 rn 代码和自己扩展的代码导致代码比较难管理。最著名的事件就是 airbnb 从最大的 react native 支持者到弃用 react native。
**weex**
weex 也是类似的思路来实现跨端的，不过他对接的上层 ui 框架是 vue，而且努力做到了双端的组件 和 api 的一致性（虽然后续维护跟不上了）。架构和上图类似。
**flutter**
flutter 是近些年流行的跨端方案，跨的端包括安卓、ios、web 等。它最大的特点是渲染不是基于操作系统的组件，而是直接基于绘图库（skia）来绘制的，这样做到了渲染的跨端。逻辑的跨端也不是基于 js 引擎，而是自研的 dart vm 来跨端，通过 dart 语言来写逻辑，
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710667723516-6fd1ab41-d95b-47b9-aa08-360b59cc5076.png#averageHue=%23a7a094&clientId=u87eb2971-fcda-4&from=paste&height=357&id=ufee92388&originHeight=714&originWidth=1346&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46680&status=done&style=none&taskId=ue7074d68-ec2e-4c88-b176-984cc9e1069&title=&width=673)
 Flutter 是由 Google 推出的一种跨平台移动应用开发框架，使用 Dart 编程语言编写。Flutter 使用自己的渲染引擎，可以在 iOS、Android、Web 和桌面平台上运行，并提供了丰富的 UI 组件和开发工具，以及高性能的渲染能力。
**kraken**
跨端包括两部分，渲染跨端和逻辑跨端。有时候只需要渲染跨端、有时候只需要逻辑跨端，有的时候需要完整的跨端引擎，这 3 种情况都有各自的适用场景。
kraken 就是一个跨端渲染引擎，基于 flutter 的绘图能力实现了 css 的渲染，实现了渲染的跨端。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710667794934-88ef77db-e6a8-4585-b224-14b5a54d2857.png#averageHue=%239e9a94&clientId=u87eb2971-fcda-4&from=paste&height=347&id=u7c28c1b8&originHeight=694&originWidth=1346&originalType=binary&ratio=2&rotation=0&showTitle=false&size=41439&status=done&style=none&taskId=u49b84f66-79f0-456f-b99f-ef1988fa2e2&title=&width=673)
**自研渲染引擎**
跨端引擎很依赖底层实现的组件和 api，用开源方案也一样得扩展这部分，所以有一定规模的团队都会选择自研。
自研跨端引擎会和 rn、weex 不同：

- 渲染部分不需要实现 virtual dom 的渲染，而是直接对接 dom api，上层应用基于这些 dom api 实现跨端渲染。这样理论上可以对接任意前端框架。
- 逻辑部分也是基于 js 引擎，通过 binding 直接注入一些 c++ 实现的 api，或者运行时通过 bridge 来注入一些安卓、ios 实现的 api。

![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710667922462-10508925-0179-40ab-aaee-8907f0aeed9e.png#averageHue=%23e5eaef&clientId=u87eb2971-fcda-4&from=paste&height=380&id=u80185f9b&originHeight=760&originWidth=1332&originalType=binary&ratio=2&rotation=0&showTitle=false&size=53903&status=done&style=none&taskId=u8e171535-d9d0-48d6-80c1-8a3e2851e24&title=&width=666)
自研跨端引擎的好处是组件和 api 可以自己扩展，更快的响应业务的需求。其中组件和 api 的双端一致性，以及统一的 api 的设计都是难点。
**跨端的通用原理是什么**
其实跨端和跨平台的思路类似，都是实现一个容器，给它提供统一的 api，这套 api 由不同的平台各自实现，保证一致的功能。
具体一些的话，**跨端分为渲染和逻辑跨端**，有的时候只需要单独的渲染跨端方案（比如 karen）和逻辑跨端方案，有的时候需要完整的跨端引擎。
weex、react native 的渲染部分都是通过实现了 virtual dom 的渲染，用安卓、ios 各自的渲染方式实现，逻辑部分使用 js 引擎，通过 bridge 注入一些安卓、ios 的 api。
flutter 则是直接使用 skia 绘图库绘制，并且逻辑跨端使用 dart vm。
但是不管具体实现怎样，思路都大同小异：**跨端引擎需要实现一个渲染引擎、实现一个 vm，基于这套架构实现各种组件和 api，跨端容器上层对接一个 ui 框架，再上层的业务代码可以基于容器的 api 实现跨端的渲染和逻辑**
**web container**
这两天 web container 比较火，其实也是一种跨平台技术，它是在浏览器里面实现的容器，通过 wasm 实现了 node 的 api，这样在这个容器里面可以跑 node 代码。其实思路比较常见，但是是一个新场景。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710668060484-b8feb64f-e0d5-446f-9ec5-982d696b3917.png#averageHue=%23d5cdc1&clientId=u87eb2971-fcda-4&from=paste&height=357&id=ufb9015a7&originHeight=714&originWidth=1394&originalType=binary&ratio=2&rotation=0&showTitle=false&size=49851&status=done&style=none&taskId=u8ad90ddc-457a-4788-a05b-e3ab47b5657&title=&width=697)
浏览器容器之上又跑了个容器，容器套娃。
### 5 如何实现样式隔离
样式隔离是指在开发 Web 应用时，确保不同组件或模块之间的样式不会相互影响，从而提高代码的可维护性和可重用性。以下是几种实现样式隔离的方法：

1. **命名约定：** 使用命名约定来确保样式的唯一性。例如，为每个组件或模块定义一个唯一的类名前缀，然后在样式表中使用该前缀来命名样式规则。这样可以确保每个组件的样式不会影响到其他组件。
2. **CSS Modules：** CSS Modules 是一种将 CSS 文件转换为模块化的技术，它能够确保每个模块中的样式只适用于该模块内部。通过使用 CSS Modules，可以避免全局作用域的样式污染，并提高代码的可维护性和可重用性。
```javascript
// 安装 CSS Modules： 首先，确保你的项目中已经安装了支持 CSS Modules 的构建工具或预处理器。
// 对于 webpack，你可以使用 css-loader 并将 modules 选项设置为 true 来启用 CSS Modules。例如：
// npm install --save-dev css-loader

import React from 'react';
import styles from './styles.css';

const MyComponent = () => {
  return (
    <div className={styles.container}>
      <h1 className={styles.title}>Hello, CSS Modules!</h1>
    </div>
  );
};

export default MyComponent;

```

3. **Scoped CSS：** 一些前端框架（如 Vue.js 和 Angular）提供了一种称为“scoped CSS”的特性，它可以将样式限定在组件的作用域内。通过使用 scoped CSS，可以确保每个组件的样式只适用于该组件内部，从而实现样式隔离。
4. **CSS-in-JS：** CSS-in-JS 是一种将 CSS 写入 JavaScript 文件中的技术，它可以将样式与组件逻辑紧密集成在一起，并确保样式的隔离性。一些流行的 CSS-in-JS 库（如 styled-components、Emotion 等）提供了样式隔离的功能，可以帮助开发者更轻松地实现样式隔离。
```javascript
import styled from 'styled-components';

const Button = styled.button`
  background-color: ${props => props.primary ? 'blue' : 'white'};
  color: ${props => props.primary ? 'white' : 'blue'};
  padding: 10px 20px;
  border: 2px solid blue;
  border-radius: 5px;
`;

const MyComponent = () => {
  return (
    <div>
      <Button primary>Primary Button</Button>
      <Button>Secondary Button</Button>
    </div>
  );
};
// 在 React 应用中，使用 CSS-in-JS 可以方便地将样式与组件逻辑结合在一起。
// 例如，使用 styled-components 或 Emotion 等 CSS-in-JS 库来定义和应用组件的样式，
// 使得每个组件都拥有自己独特的样式规则，并且可以根据组件的状态或属性动态生成样式。
```

5. **Shadow DOM：** Shadow DOM 是一种将 DOM 树封装在一个封闭的影子 DOM 树中的技术，它可以确保影子 DOM 树内部的样式不会影响到外部的 DOM 树。通过使用 Shadow DOM，可以实现 Web 组件的样式隔离，从而提高代码的可维护性和可重用性。

无论使用哪种方法，样式隔离都是前端开发中非常重要的一环，它可以帮助开发者避免样式污染和不必要的样式冲突，提高代码的质量和可维护性。选择合适的样式隔离方法取决于项目的需求和个人偏好。
### 6 如何进行移动端的调试
移动端调试是移动端开发过程中至关重要的一部分，下面是一些常见的移动端调试方法：

1. **使用浏览器开发者工具：** 现代的移动浏览器（如 Chrome、Safari 等）都提供了开发者工具，可以通过 USB 连接将移动设备连接到开发者工具，并在开发者工具中进行调试。你可以在开发者工具中查看页面的 DOM 结构、网络请求、JavaScript 控制台等信息，并且可以模拟不同的移动设备和网络条件。
> - Chrome浏览器 + Android
> 
使用Chrome中的 Inspect，直接在PC端调试android机器中的webview的页面。
> - Mac + IOS + Safari
> 
方法基本同上

2. **远程调试工具：** 一些第三方工具（如 Weinre、Vysor 等）可以帮助你通过 USB 或 WiFi 连接将移动设备连接到电脑，并在电脑上进行远程调试。这些工具通常提供了更多的调试功能和选项，可以帮助你更方便地定位和解决问题。
> Weinre（Web Inspector Remote）是一个用于远程调试移动端网页的工具，它允许开发者在桌面浏览器中远程查看和调试移动设备上运行的网页。以下是使用 Weinre 进行移动端调试的基本步骤：
> 1. **安装 Weinre：** 首先，你需要安装 Weinre，你可以通过 npm 进行安装：
> 
npm install -g weinre
> 2. **启动 Weinre 服务器：** 在命令行中执行以下命令来启动 Weinre 服务器：
> 
weinre --boundHost -all-
> 这将启动一个 Weinre 服务器，并监听默认端口 8080。
> 3. **添加 Weinre 脚本：** 在你要调试的移动端网页中添加以下脚本标签，将其中的 **your-weinre-host** 替换为你的电脑的 IP 地址和 Weinre 服务器监听的端口号（默认为 8080）：
> 
<script src="http://your-weinre-host:8080/target/target-script-min.js#anonymous"></script>
> 你可以在浏览器中输入 **http://localhost:8080/client/#anonymous** 查看 Weinre 控制台的页面，并在这个页面中找到脚本标签。
> 4. **连接移动设备：** 在移动设备的浏览器中访问你要调试的网页，并等待页面加载完成。
> 5. **在 Weinre 控制台中调试：** 打开 Weinre 控制台页面，你应该能够看到连接到服务器的移动设备。点击设备图标即可查看该设备的调试信息，包括页面 DOM 结构、样式、JavaScript 控制台等。
> 
通过以上步骤，你就可以使用 Weinre 进行移动端网页的远程调试了。请注意，Weinre 在安全性和功能方面可能不如其他工具（如 Chrome DevTools），但它提供了一种简单且有效的方法来调试移动端网页，特别是在没有其他工具支持的情况下。

3. **使用模拟器和仿真器：** 除了真实的移动设备，你还可以使用模拟器和仿真器来进行移动端调试。模拟器和仿真器通常会模拟真实的移动设备环境，并提供类似于真实设备的用户体验和功能。你可以使用 Android Studio 自带的模拟器或 Xcode 自带的模拟器来模拟 Android 和 iOS 设备，或者使用第三方模拟器（如 Genymotion、Appetize.io 等）来模拟各种移动设备和操作系统。
4. **使用调试工具和库：** 一些调试工具和库（如 Eruda、VConsole 等）可以帮助你在移动端页面中添加调试信息和功能，如查看页面元素、执行 JavaScript、查看网络请求等。这些工具和库通常以 JavaScript 插件的形式集成到页面中，可以方便地在移动设备上使用。
> - vConsole：Web 调试面板
> 
vConsole 会在你网页中加一个悬浮的小按钮，可以点击它来打开关闭调试面板，并查看 DOM、Console、Network和 本地存储 等信息。基本可以满足普通前端开发的需求。使用方法也很简单，通过npm安装或者直接在需要的页面引入 js文件 ，然后 new VConsole() 就可以了。
> - Charles
> 
Charles 是一款强大的抓包工具，可以截取包括 https 在内的各种网络请求并方便的查看具体信息。有 Mac、Windows 和 Linux多版本，通过配置 WIFI 代理，也可以拦截手机发出的请求。毕竟前端相当一部分报错是网络错误或数据不符合预期导致的（甩锅后端😄）。所以通过拦截 http 请求,查看具体的请求信息和数据，能获取很多有用的信息，可以在一定程度上帮助 debug。

5. **响应式设计模式：** 使用响应式设计模式开发移动端页面时，可以在桌面浏览器中模拟移动设备的效果。通过调整浏览器窗口大小或使用开发者工具中的响应式设计模式，你可以模拟不同移动设备的屏幕尺寸和分辨率，以检查页面在不同设备上的显示效果和布局响应性。
> 响应式设计模式是一种网页设计方法，旨在使网站能够在不同设备上提供最佳的用户体验。在开发移动端页面时，使用响应式设计模式意味着设计和构建页面时考虑了不同设备的屏幕尺寸、分辨率和触控方式，并针对不同设备做出相应的布局和样式调整，以确保页面在各种设备上都能够自适应地显示和响应用户的操作。

综上所述，移动端调试是移动端开发过程中不可或缺的一部分，通过合适的调试工具和方法，你可以更快地定位和解决问题，提高开发效率和质量。
### 7 git HEAD、工作树、索引
在git中，可以存在很多分支，其本质上是一个指向commit对象的可变指针，而Head是一个特别的指针，是一个指向你正在工作中的本地分支的指针
简单来讲，就是你现在在哪儿，HEAD 就指向哪儿
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710732585285-ad2f1003-0290-4f89-8ee2-800b573ae07f.png#averageHue=%23fefefe&clientId=u87eb2971-fcda-4&from=paste&height=227&id=u0e042483&originHeight=453&originWidth=713&originalType=binary&ratio=2&rotation=0&showTitle=false&size=10065&status=done&style=none&taskId=u61888245-2af6-4a53-af8f-31c675eb367&title=&width=356.5)
例如当前我们处于master分支，所以HEAD这个指针指向了master分支指针
然后通过调用git checkout test切换到test分支，那么HEAD则指向test分支，如下图：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710732598279-3670dd77-902e-4b7d-9fee-d0bf307d32a3.png#averageHue=%23fefefe&clientId=u87eb2971-fcda-4&from=paste&height=229&id=u716488df&originHeight=457&originWidth=709&originalType=binary&ratio=2&rotation=0&showTitle=false&size=9911&status=done&style=none&taskId=u68a5662b-d156-46ee-9bf7-e89923422da&title=&width=354.5)
但我们在test分支再一次commit信息的时候，HEAD指针仍然指向了test分支指针，而test分支指针已经指向了最新创建的提交，如下图：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710732624446-d450f1e0-d09f-4a3f-b79f-c0e8e32fbf38.png#averageHue=%23fefefe&clientId=u87eb2971-fcda-4&from=paste&height=357&id=udaba73f9&originHeight=714&originWidth=1292&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42921&status=done&style=none&taskId=u759bf555-f7a5-4b88-bdeb-73c66d2f39f&title=&width=646)
HEAD指针 ——–> 分支指针 ——–> 最新提交

在Git管理下，大家实际操作的目录被称为工作树，也就是工作区域
在数据库和工作树之间有索引，索引是为了向数据库提交作准备的区域，也被称为暂存区域
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710732688685-dc2783e8-df3d-43c7-9695-3352f630dae1.png#averageHue=%23f7f4ed&clientId=u87eb2971-fcda-4&from=paste&height=183&id=u7c2c4de1&originHeight=365&originWidth=735&originalType=binary&ratio=2&rotation=0&showTitle=false&size=24488&status=done&style=none&taskId=uca72229e-7958-46c7-a6e7-808f28c0c92&title=&width=367.5)
所以，凭借中间的索引，可以避免工作树中不必要的文件提交，还可以将文件修改内容的一部分加入索引区域并提交。
总结：

- HEAD 指针通常指向我们所在的分支，当我们在某个分支上创建新的提交时，分支指针总是会指向当前分支的最新提交
- 工作树是查看和编辑的（源）文件的实际内容
- 索引是放置你想要提交给 git仓库文件的地方，如工作树的代码通过 git add 则添加到 git 索引中，通过git commit 则将索引区域的文件提交到 git 仓库中
### 8 git merge/rebase  reset/revert   fetch/pull
merge和rebase都是合并历史记录，但是各自特性不同：
**merge**
通过merge合并分支会新增一个merge commit，然后将两个分支的历史联系起来
其实是一种非破坏性的操作，对现有分支不会以任何方式被更改，但是会导致历史记录相对复杂
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710728056350-6e27581d-c469-491f-93b3-7d6271926550.png#averageHue=%23f9f9f9&clientId=u87eb2971-fcda-4&from=paste&height=100&id=ud8f28dc2&originHeight=200&originWidth=717&originalType=binary&ratio=2&rotation=0&showTitle=false&size=9278&status=done&style=none&taskId=uc968cbdb-bbba-4401-856f-c27e27e06f3&title=&width=358.5)
**rebase**
rebase 会将整个分支移动到另一个分支上，有效地整合了所有分支上的提交
主要的好处是历史记录更加清晰，是在原有提交的基础上将差异内容反映进去，消除了 git merge所需的不必要的合并提交
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710728028008-3b5ea957-bff5-44ac-8a3e-460caaa18146.png#averageHue=%23f8f7f7&clientId=u87eb2971-fcda-4&from=paste&height=89&id=u4332bb8e&originHeight=178&originWidth=747&originalType=binary&ratio=2&rotation=0&showTitle=false&size=11425&status=done&style=none&taskId=u5b9183b4-bc90-4bab-8e74-09a7ca98319&title=&width=373.5)

> 将当前分支移植到指定分支或指定commit之上，用法如下：
> git rebase -i <commit>
> 常见的参数有--continue，用于解决冲突之后，继续执行rebase
> git rebase --continue
> 
> feature-test:     git fetch 	git rebase origin master	git add . 	git rebase --continue
> master: git merge feature-test(FastForward)     增加--no-ff 强行增加一个 commit

**revert/reset**
撤销（revert）被设计为撤销公开的提交（比如已经push）的安全方式，
git reset被设计为重设本地更改
因为两个命令的目的不同，它们的实现也不一样：重设完全地移除了一堆更改，
而撤销保留了原来的更改，用一个新的提交来实现撤销
两者主要区别如下：

- git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
- git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容
- 在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别

git revert是用一次逆向的commit“中和”之前的提交，因此日后合并老的branch时，之前提交合并的代码仍然存在，导致不能够重新合并
但是git reset是之间把某些commit在某个branch上删除，因而和老的branch再次merge时，这些被回滚的commit应该还会被引入

- 如果回退分支的代码以后还需要的情况则使用git revert， 如果分支是提错了没用的并且不想让别人发现这些错误代码，则使用git reset

**git pull/git fetch**
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710730907869-d0f877d5-71b0-4040-8034-235fc1c0cfd1.png#averageHue=%23e8e8c5&clientId=u87eb2971-fcda-4&from=paste&height=166&id=u6bf1271f&originHeight=332&originWidth=1053&originalType=binary&ratio=2&rotation=0&showTitle=false&size=30472&status=done&style=none&taskId=u632cb286-f562-4e41-b5cd-b83682a2a55&title=&width=526.5)
在我们本地的git文件中对应也存储了git本地仓库分支的commit ID 和 跟踪的远程分支的commit ID，对应文件如下：

- .git/refs/head/[本地分支]
- .git/refs/remotes/[正在跟踪的分支]

使用 git fetch更新代码，本地的库中master的commitID不变
但是与git上面关联的那个orign/master的commit ID发生改变
这时候我们本地相当于存储了两个代码的版本号，我们还要通过merge去合并这两个不同的代码版本
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710731959343-fe6a1483-2d41-49d6-b5f3-4aa54dea7de5.png#averageHue=%23e8e8e8&clientId=u87eb2971-fcda-4&from=paste&height=201&id=ua244d918&originHeight=401&originWidth=638&originalType=binary&ratio=2&rotation=0&showTitle=false&size=14729&status=done&style=none&taskId=ube2d576c-bc03-47aa-90e1-f2b8e4c06be&title=&width=319)
也就是fetch的时候本地的master没有变化，但是与远程仓关联的那个版本号被更新了，接下来就是在本地merge合并这两个版本号的代码
相比之下，使用git pull就更加简单粗暴，会将本地的代码更新至远程仓库里面最新的代码版本，如下图：
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1710731997433-a4eed901-8ca9-4316-a7bb-a45628a3d243.png#averageHue=%23e7e7e7&clientId=u87eb2971-fcda-4&from=paste&height=206&id=u15eb75b1&originHeight=412&originWidth=648&originalType=binary&ratio=2&rotation=0&showTitle=false&size=15067&status=done&style=none&taskId=ud8df5d04-29c0-45e4-a3ad-c589765c4e1&title=&width=324)
例如从远程的origin仓库的master分支下载代码到本地并新建一个temp分支
git fetch origin master:temp
如果上述没有冒号，则表示将远程origin仓库的master分支拉取下来到本地当前分支
这里git fetch不会进行合并，执行后需要手动执行git merge合并，如下：
git merge temp
例如将远程主机origin的master分支拉取过来，与本地的branchtest分支合并，命令如下：
git pull origin master:branchtest
同样如果上述没有冒号，则表示将远程origin仓库的master分支拉取下来与本地当前分支合并
### 9 微前端
[qiankun 微前端方案实践及总结](https://juejin.cn/post/6844904185910018062)
> 微前端就是可以一个页面跑多个 vue、react 甚至 jquery 等不同项目，它之间的 JS、CSS 相互隔离运行，不会相互影响，但也有通信机制可以通信。
> 那微前端怎么实现呢？其实也简单，一句话就可以说明白：**当路由切换的时候，去下载对应应用的代码，然后跑在容器里。**

微前端是一种架构风格，旨在解决大型前端应用程序的开发和维护难题，特别是在大型团队或组织中。它将前端应用程序拆分为一系列更小、更独立的部分，每个部分称为微前端，这些微前端可以由不同的团队或开发者独立开发、测试和部署。微前端的目标是提高团队的独立性、灵活性和可维护性，同时保持整体应用程序的一致性和性能。
以下是微前端的核心概念和关键特点：

1. **拆分应用程序：** 微前端将大型前端应用程序拆分为多个独立的微前端，每个微前端负责管理自己的代码、资源和状态。这种拆分可以根据业务功能、团队组织或技术栈等因素进行划分。
2. **独立开发和部署：** 每个微前端都可以由不同的团队或开发者独立开发、测试和部署，它们之间彼此隔离，互不影响。这种独立性使得团队可以更快地迭代和交付功能，而无需等待其他团队的工作。
3. **松耦合架构：** 微前端之间通过定义好的接口或协议进行通信和集成，它们之间尽可能保持松耦合。这种松耦合架构使得每个微前端可以独立开发和演化，而不会影响整个应用程序的稳定性和性能。
4. **共享基础设施：** 尽管微前端是相互独立的，但它们仍然可以共享某些基础设施，如共享组件库、样式库、路由管理等。这些共享的基础设施可以提高开发效率，减少重复工作。
5. **整合和路由管理：** 微前端需要一个主应用程序来整合所有微前端，并负责处理路由管理、状态管理、数据共享等跨微前端的逻辑。这个主应用程序通常称为微前端容器或微前端框架。

微前端的优势在于它能够解决大型前端应用程序的复杂性和可维护性问题，同时提高团队的独立性和灵活性。它适用于大型团队或组织中开发和维护多个前端应用程序的场景，尤其是在面临快速迭代、不断变化的需求和技术栈多样化的情况下。
> 目前主流的微前端方案包括以下几个：

- iframe
- 基座模式，主要基于路由分发，qiankun 和 single-spa 就是基于这种模式
- 组合式集成，即单独构建组件，按需加载，类似 npm 包的形式
- EMP，主要基于 Webpack5 Module Federation
- Web Components
> 严格来讲，这些方案都不算是完整的微前端解决方案，它们只是用于解决微前端中运行时容器的相关问题。

#### iframe 方案
iframe 大家都很熟悉，使用简单方便，提供天然的 js/css 隔离，也带来了数据传输的不便，一些数据无法共享（主要是本地存储、全局变量和公共插件），两个项目不同源（跨域）情况下数据传输需要依赖 postMessage 。
iframe 有很多坑，但是大多都有解决的办法：

1. 页面加载问题

iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载，阻塞 onload 事件。每次点击都需要重新加载，虽然可以采用 display:none 来做缓存，但是页面缓存过多会导致电脑卡顿。(无法解决)

2. 布局问题

iframe 必须给一个指定的高度，否则会塌陷。
解决办法：子项目实时计算高度并通过 postMessage 发送给主页面，主页面动态设置 iframe 高度。有些情况会出现多个滚动条，用户体验不佳。

3. 弹窗及遮罩层问题

弹窗只能在 iframe 范围内垂直水平居中，没法在整个页面垂直水平居中。

- 解决办法1：通过与框架页面消息同步解决，将弹窗消息发送给主页面，主页面来弹窗，对原项目改动大且影响原项目的使用。
- 解决办法2：修改弹窗的样式：隐藏遮罩层，修改弹窗的位置。
4. iframe 内的 div 无法全屏

弹窗的全屏，指的是在浏览器可视区全屏。这个全屏指的是占满用户屏幕。
全屏方案，原生方法使用的是 Element.requestFullscreen()，插件：[vue-fullscreen](https://link.juejin.cn?target=https%3A%2F%2Fmirari.cc%2F2017%2F08%2F14%2F%25E5%2585%25A8%25E5%25B1%258F%25E5%2588%2587%25E6%258D%25A2%25E7%25BB%2584%25E4%25BB%25B6vue-fullscreen%2F)。当页面在 iframe 里面时，全屏会报错，且 dom 结构错乱。
解决方案：iframe 标签设置 allow="fullscreen" 属性即可

5. 浏览器前进/后退问题

iframe 和主页面共用一个浏览历史，iframe 会影响页面的前进后退。大部分时候正常，iframe 多次重定向则会导致浏览器的前进后退功能无法正常使用。并且 iframe 页面刷新会重置（比如说从列表页跳转到详情页，然后刷新，会返回到列表页），因为浏览器的地址栏没有变化，iframe 的 src 也没有变化。

6. iframe 加载失败的情况不好处理

非同源的 iframe 在火狐及 chorme 都不支持 onerror 事件。

- 解决办法1：onload 事件里面判断页面的标题，是否 404 或者 500
- 解决办法2：使用 try catch 解决此问题，尝试获取 contentDocument 时将抛出异常。

解决办法参考：[stackoverflow上的问题：Catch error if iframe src fails to load](https://link.juejin.cn?target=https%3A%2F%2Fstackoverflow.com%2Fquestions%2F15273042%2Fcatch-error-if-iframe-src-fails-to-load-error-refused-to-display-http-ww)
#### 微前端框架 
微前端的核心是一个主应用程序，它负责整合和管理所有的微前端，并提供路由管理、状态管理、数据共享等跨微前端的功能。常见的微前端框架包括 single-spa、qiankun、mooa 等，它们提供了一套完整的解决方案来实现微前端架构。
#### qiankun的核心设计理念

- 🥄 简单
由于主应用微应用都能做到技术栈无关，qiankun 对于用户而言只是一个类似 jQuery 的库，你需要调用几个 qiankun 的 API 即可完成应用的微前端改造。同时由于 qiankun 的 HTML entry 及沙箱的设计，使得微应用的接入像使用 iframe 一样简单。
- 🍡 解耦/技术栈无关
微前端的核心目标是将巨石应用拆解成若干可以自治的松耦合微应用，而 qiankun 的诸多设计均是秉持这一原则，如 HTML entry、沙箱、应用间通信等。这样才能确保微应用真正具备独立开发、独立运行 的能力。

**特性**

- 📦 基于 single-spa 封装，提供了更加开箱即用的 API。
- 📱 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。
- 💪 HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。
- 🛡 样式隔离，确保微应用之间样式互相不干扰。
- 🧳 JS 沙箱，确保微应用之间 全局变量/事件 不冲突。
- ⚡️ 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。
- 🔌 umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。
#### 实现
那微前端怎么实现呢？
其实也简单，一句话就可以说明白：**当路由切换的时候，去下载对应应用的代码，然后跑在容器里。**
比如 single-spa，它做的就是监听路由变化，路由切换的时候加载、卸载注册的应用的代码。
只不过 single-spa 的入口是一个 js 文件，需要代码里手动指定要加载啥 js、css 等，不方便维护。
qiankun 只是对 single-spa 的升级。
它升级了啥东西呢？
第一个就是入口，改为了 html 作为入口，解析 html，从中分析 js、css，然后再加载，这个是 **import-html-entry** 这个包实现的。
所以你在 qiankun 的 package.json 里可以看到 single-spa 和 import-html-entry 这俩依赖。
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711167253600-c7c71a33-f27b-4571-938f-b63f7d3d1eb0.webp#averageHue=%232a2727&clientId=u65656ca1-52b2-4&from=paste&id=ua74b691d&originHeight=416&originWidth=1454&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u8aff2a2d-bac0-4119-a86a-743968e0926&title=)
加载之后呢？
自然是放容器里运行呀。
这个容器 single-spa 也没做，qiankun 做了。
它是把 js 代码包裹了一层 function，然后再把内部的 window 用 Proxy 包一层，这样内部的代码就被完全隔离了，这样就实现了一个 JS 沙箱。
这部分代码在 import-html-entry 里，也就是加载后的 js 就被包裹了一层：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711167253583-66dd1783-53df-4f7a-9e17-ad6a1dc46b22.webp#averageHue=%23232120&clientId=u65656ca1-52b2-4&from=paste&id=ua685e046&originHeight=792&originWidth=1512&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u939e98a0-18cb-49e3-97ee-6a8216a9ead&title=)
原理很容易理解，就是 function 包裹了一层，所以代码放在了单独作用域跑，又用 with 修改了 window，所以 window 也被隔离了。
这是 qiankun 的 J**S 沙箱实现方案**，其他的微前端方式实现沙箱可能用 iframe、web components 等方式。
微前端方案的功能就那一句话：当路由切换的时候，去下载对应应用的代码，然后跑在容器里。只不过这个容器的实现方案有差异。
此外，还要设计一套通信机制，这个倒是很容易。
除了 JS 隔离，还有** CSS 的隔离**，不得不说，qiankun 的样式隔离是真的坑，也是我这主要想吐槽的点。
qiankun 提供了两种样式隔离方案：shadow dom 和它自己实现的 scoped。但是都有问题。
[**案例详见**](https://juejin.cn/post/7184419253087535165)
css modules 和 scoped css 差不多，都能实现组件级别样式隔离，能设置子组件和全局样式。只是实现方式不同，导致了使用起来也有差异。
不管是 css modules 还是 scoped css 都比 qiankun 自带的样式隔离方案好用的多，那为什么微前端框架还要实现样式隔离呢？直接让应用自己去用 css modules 或者 scoped css 不就行了？那是因为还有一些别的项目，比如 jquery 项目，你怎么用 css modules？就算用，是不是要改造，改造成本又上去了。所以微前端框架还是要做样式隔离的。
只是现在的应用，不管是 vue 还是 react 基本都开启了**组件级别样式隔离**，qiankun 自带的样式隔离问题太多了，不如不用。
#### 扩展：scoped css和 css modules
**scoped css **
scoped css 是 vue loader 实现的组件级样式隔离方案，用起来只要给单文件组件的 style 加一个 scoped 属性：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183674813-cd3689ea-7e4b-4840-9c3f-d563f75eccb3.webp#averageHue=%23282523&clientId=u65656ca1-52b2-4&from=paste&id=uaec2b415&originHeight=190&originWidth=760&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u18882a7f-bc0d-40ab-9e80-641f114cebc&title=)
**cs**s 选择器就会加上 data-xx 的修饰，这样就限制了样式只会在组件范围内生效。
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183674852-cab3742f-fdf5-4776-81d8-30792bf8a459.webp#averageHue=%23fcfdf9&clientId=u65656ca1-52b2-4&from=paste&id=uc6508ffd&originHeight=260&originWidth=1512&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1010a306-3a38-4082-9a12-6cb6f23c5a6&title=)
只会在最后一个选择器加 data-xxx，因为这样足够了：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183674790-500bac57-6feb-4864-82d7-669f0cc9343f.webp#averageHue=%23242321&clientId=u65656ca1-52b2-4&from=paste&id=u42d910a9&originHeight=346&originWidth=496&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ued109870-401a-4545-9847-eea13559915&title=)
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183674826-eb2bea64-bb12-443c-b734-a35568cdf086.webp#averageHue=%23fcfcf9&clientId=u65656ca1-52b2-4&from=paste&id=u4747cd36&originHeight=80&originWidth=610&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=uc59cb71b-c808-418a-b385-dd607539d7d&title=)
此外它还支持 /deep/ 控制子元素样式：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183674831-e387c9ad-83f9-4755-88ef-0c477b0041a9.webp#averageHue=%23252422&clientId=u65656ca1-52b2-4&from=paste&id=ufe6142ba&originHeight=360&originWidth=500&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u35dcff1e-6dcd-46e7-9416-d7b09d1190e&title=)
这样 deep 后面的样式是不带 data-xx 的，可以影响子组件：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183675207-21a0308b-050d-4724-b285-cb1307fddeb4.webp#averageHue=%23fcfbfb&clientId=u65656ca1-52b2-4&from=paste&id=ud2320005&originHeight=110&originWidth=816&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=uea3e93f6-2764-4646-ae90-4c673840140&title=)
此外，也可以再开一个 style 标签写全局的样式：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183675372-2ee2ab1e-dbe1-450f-afc8-30ffb514001f.webp#averageHue=%23232221&clientId=u65656ca1-52b2-4&from=paste&id=u9119076a&originHeight=352&originWidth=614&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u3d6ff924-af2f-4270-9743-af42e154a33&title=)
综上，scoped css 支持组件级别样式隔离，还能传样式给子组件、设置全局样式等。
功能上比 qiankun 的那个应用级样式隔离完善多了。
有了 scoped css，还需要 qiankun 的样式隔离么？完全不用。
**css modules**
再来看 css modules，react 项目基本都用这个。
css modules 是 css-loader 实现的功能，开启也是相当简单：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882177-bad2c487-9a7b-49bc-aa1a-ef4174309eff.webp#averageHue=%23f5f4f4&clientId=u65656ca1-52b2-4&from=paste&id=u796d3435&originHeight=608&originWidth=636&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u48aa133a-dc2a-4be8-9ba8-d9941ce0e50&title=)
比如这样的样式：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183883156-61701d47-ffa9-4d8b-b02c-36f1d0828f9b.webp#averageHue=%23262523&clientId=u65656ca1-52b2-4&from=paste&id=u7f93e8a0&originHeight=440&originWidth=572&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u4ddc2828-f609-4e07-991e-69eec00152b&title=)
开启后就会变成这样：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882220-dd778ee5-25a6-4f96-968f-ca2199f3c02d.webp#averageHue=%23fefdfa&clientId=u65656ca1-52b2-4&from=paste&id=u31bd9d21&originHeight=196&originWidth=776&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u63f7f333-68ff-4c19-93e2-ecae1791802&title=)
在选择器名字上加了 hash。
那么问题来了，scoped css 是多了一个属性选择器而已，本身的 class name 没变：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882281-d3850072-9d0d-4287-a3d6-2779cd3df4f0.webp#averageHue=%23fcfdf9&clientId=u65656ca1-52b2-4&from=paste&id=u0930aa76&originHeight=260&originWidth=1512&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u0413f025-0805-4017-85f2-00030446022&title=)
所以 class name 该怎么设怎么设，不受影响。
但是 css modules 是改变 class name 本身，加上了 hash：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882178-1ec8c64e-11d2-4f07-9e7d-e5580205c5ff.webp#averageHue=%23fefdf9&clientId=u65656ca1-52b2-4&from=paste&id=u1f5327fa&originHeight=196&originWidth=776&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u3ae63aa5-a054-4b59-9933-07103027c8f&title=)
这时候还按照原来的方式写 class name 可以么？
不可以了。
因为最终的 class name 是编译后才生成的，所以要改成这样的方式：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882759-bd5a0aee-9140-460c-8583-91076c1e3d1c.webp#averageHue=%23232120&clientId=u65656ca1-52b2-4&from=paste&id=udb9e43e9&originHeight=284&originWidth=1204&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ufab1dd63-2dcf-4420-b179-14ad32a9905&title=)
动态引入 className，这样编译生成最终的 className 时就会替换这里。
你还可以加个 :global() 把某个选择器变为全局的：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882788-de375541-1a6a-4572-9b88-026994325ef6.webp#averageHue=%23262422&clientId=u65656ca1-52b2-4&from=paste&id=uec5d9dcc&originHeight=456&originWidth=604&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u71164328-a97f-42b5-a437-87d7434531e&title=)
这样就相当于 scoped css 的 /deep/ 和全局样式功能了。
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183882969-72eb1426-fef9-4c61-812a-a70614237dd2.webp#averageHue=%23fefcf9&clientId=u65656ca1-52b2-4&from=paste&id=u016c0d5f&originHeight=204&originWidth=678&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u55aae73c-5175-4d26-a5b6-18276d9abb9&title=)
一般都这样用：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183883008-9b639806-37ce-4a73-9ef4-7e5f1eb601a8.webp#averageHue=%23242221&clientId=u65656ca1-52b2-4&from=paste&id=ue9a043b4&originHeight=712&originWidth=638&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u0dc74f08-8bde-4dd0-ac0c-f5ebf148899&title=)
顶层 class name 用 css modules 加上 hash，内部的 class name 该怎么用怎么用：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183883528-b848945f-fbf5-4008-bf81-408fcdfb83b2.webp#averageHue=%23222120&clientId=u65656ca1-52b2-4&from=paste&id=u7f83d709&originHeight=458&originWidth=1026&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ubcaef23f-adee-4853-8034-e9b049e7bb0&title=)
生成的 css 是这样的：
![](https://cdn.nlark.com/yuque/0/2024/webp/40468162/1711183883682-7d479d39-f214-4916-86ad-a1a62e362256.webp#averageHue=%23fefefb&clientId=u65656ca1-52b2-4&from=paste&id=ud40b2fa5&originHeight=294&originWidth=694&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u68746b85-4b15-4c02-9058-fde3d9b88f3&title=)
既达到了组件样式隔离的目的，写起来还简单。
综上，**css modules 和 scoped css 差不多，都能实现组件级别样式隔离，能设置子组件和全局样式。只是实现方式不同，导致了使用起来也有差异。**
#### qiankun的使用
qiankun 是一个基于 single-spa 的微前端解决方案，它可以帮助你将多个独立开发的前端应用整合成一个整体应用。下面是使用 qiankun 的基本步骤：

1. **安装 qiankun：** 首先，在你的主应用程序中安装 qiankun 包：
```
npm install qiankun --save
```

2. **注册子应用：** 在主应用程序中，使用 **registerMicroApps** 方法注册你的子应用程序。每个子应用程序都需要提供一个唯一的名称、入口路径、渲染函数和路由前缀等信息。
```
import { registerMicroApps, start } from 'qiankun';

registerMicroApps([
  {
    name: 'app1',
    entry: '//localhost:8081',
    container: '#app1',
    activeRule: '/app1',
  },
  // 添加更多的子应用配置...
]);

start();
```

3. **启动主应用程序：** 启动主应用程序，并将 qiankun 容器（**#app1**、**#app2** 等）添加到主应用程序的 HTML 中，用来渲染子应用程序。
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Main App</title>
</head>
<body>
  <div id="app"></div>
  <!-- 添加更多的容器... -->

  <script src="https://unpkg.com/qiankun"></script>
  <script src="./main.js"></script>
</body>
</html>
```

4. **启动子应用程序：** 启动每个子应用程序，并确保子应用程序的 HTML 元素 ID 与注册时指定的容器 ID 一致。
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sub App 1</title>
</head>
<body>
  <div id="app1"></div>

  <script src="./main.js"></script>
</body>
</html>
```

5. **启动应用程序：** 在每个子应用程序中，通过调用 **start** 方法启动应用程序。这样，子应用程序就会在主应用程序的容器中进行渲染，并且在符合 **activeRule** 规则的情况下被激活。
```
import { start } from 'qiankun';

start();
```
通过以上步骤，你就可以使用 qiankun 将多个独立的前端应用整合成一个整体应用，并且可以独立开发、测试和部署每个子应用程序，同时保持主应用程序的稳定性和性能。
#### 样式污染问题
在使用 qiankun 或其他微前端框架时，样式错乱可能会是一个潜在的问题。这主要取决于你的子应用程序是如何编写和组织的，以及你如何处理全局样式和作用域样式的问题。
以下是一些可能导致样式错乱的情况以及解决方法：

1. **全局样式冲突：** 如果子应用程序和主应用程序使用了相同的全局样式，可能会导致样式冲突。为了解决这个问题，你可以使用命名空间或作用域限定来确保样式不会互相干扰。比如，使用 [BEM（Block Element Modifier）命名规范](https://juejin.cn/post/6844903672162304013)来定义样式，或者使用 CSS Modules、Scoped CSS 等技术来限定样式的作用域。
2. **CSS 选择器优先级冲突：** 如果子应用程序和主应用程序使用了相同的 CSS 选择器，并且优先级相同，可能会导致样式冲突。为了解决这个问题，你可以使用更具体的 CSS 选择器或者提高子应用程序样式的优先级，以确保子应用程序的样式能够正确应用。
3. **样式重置和统一：** 可以在主应用程序中为整个应用程序定义一套样式重置或统一的样式，以确保整个应用程序的样式风格统一。这样可以减少样式冲突的可能性，并提高整个应用程序的可维护性和一致性。
4. **避免直接操作全局样式：** 在子应用程序中尽量避免直接操作全局样式，而是使用局部样式或者组件样式来定义样式。这样可以减少样式冲突的可能性，并使得子应用程序更加独立和可重用。

总的来说，样式错乱在使用 qiankun 或其他微前端框架时是一个需要注意的问题，但通过合适的样式组织和管理，以及遵循良好的前端开发实践，你可以有效地避免样式错乱问题，并确保整个应用程序的样式表现正常
**解决 qiankun 微前端应用中样式错乱问题**
关键是要确保样式的作用域隔离和正确加载。以下是一些解决 qiankun 样式错乱问题的方法：

1. **CSS Module 或 CSS-in-JS**: 使用 CSS Module 或 CSS-in-JS 等技术来实现样式的局部作用域，确保每个微前端应用的样式不会影响到其他应用。这样可以避免全局样式污染和样式冲突。
2. **Scoped CSS 或 Shadow DOM**: 在 qiankun 的子应用中，可以使用 Scoped CSS 或 Shadow DOM 等技术来实现样式的作用域隔离，确保每个子应用的样式不会影响到其他子应用或宿主应用。
3. **CSS Reset 或 Normalize.css**: 在微前端应用的入口文件中引入 CSS Reset 或 Normalize.css 等全局样式重置库，以确保不同子应用的初始样式状态一致，从而减少样式错乱的可能性。
4. **避免全局样式冲突**: 尽量避免在微前端应用中使用全局样式，而是将样式限定在组件范围内，这样可以减少样式冲突的可能性。
5. **加载顺序控制**: 确保微前端应用及其相关资源（包括样式表）按正确的顺序加载，避免样式加载过程中的问题导致样式错乱或页面闪烁。
6. **样式检查和测试**: 定期进行样式检查和测试，确保页面在不同环境和加载顺序下都能正确显示，并及时修复样式错乱的问题。

通过以上方法，可以有效地解决 qiankun 微前端应用中的样式错乱问题，确保页面样式的一致性和稳定性。
### 10 模块联邦
自webpack5发布以来，推出了很多全新的特性，其中最主要的就如下三点：
① 可持续性缓存--通过cache配置可实现首次构建后一直保存缓存。
② 真正意义上的tree-shaking--让你的打包体积更小，去掉无用的代码。
③ 模块联邦（module federation）--本文需要探讨实战的特性；
**模块联邦**
webpack官方解释： 多个独立的构建可以组成一个应用程序，这些独立的构建之间不应该存在依赖关系，因此可以单独开发和部署它们。
模块联邦可以在多个 webpack 编译产物之间共享模块、依赖、页面甚至应用，通过全局变量的组合，还可以在不同模块之前进行数据的获取，让跨应用间做到模块共享，真正的插拔式的便捷使用。比如a应用如果想使用b应用中table的组件，通过模块联邦可以直接在a中进行import('b/table')非常的方便。
可以理解为一种解决应用集的方案， 每个构建都充当一个容器，也可将其他构建作为容器。通过这种方式，每个构建都能够通过从对应容器中加载模块来访问其他容器暴露出来的模块。
线上 Runtime(运行时) 的效果，让代码直接在项目间利用 CDN 直接共享，不再需要本地安装npm 包、构建再发布了。
简单来说，我可以将自己的模块共享出去，也可以使用其他项目的模块。
这通常被称为微前端，例如我们的single-spa，qiankun，但是模块联邦远不止如此。
**由来动机**
模块联邦的动机是为了不同开发小组间开发一个或者多个应用。
应用将被划分为更小的应用块，一个应用块，例如头部导航或者侧边栏的前端组件。
每个应用块由不同的小组开发。
应用块需要共享给其他应用块或者容器。
**过程**
1. 每个应用块都是一个独立的构建，这些构建都将编译成容器。
2. 容器可以被其他应用或者其他容器应用。
3. 一个被引用得容器或称为remote，引用者被称为host，remote暴露模块给host，host则可以使用这些暴露的模块，这些模块被称为remote模块。
![image.png](https://cdn.nlark.com/yuque/0/2024/png/40468162/1711191094083-21e7f100-90ac-4f2f-9adc-bd8070273bbe.png#averageHue=%23f1f1f1&clientId=u65656ca1-52b2-4&from=paste&height=173&id=u371b5682&originHeight=345&originWidth=1357&originalType=binary&ratio=2&rotation=0&showTitle=false&size=89513&status=done&style=none&taskId=u8b00354c-234f-4ac0-ab63-2d6d531f1c1&title=&width=678.5)
**底层分析**
分为本地模块和远程模块，本地模块即为普通模块，是当前构建的一部分，远程模块不属于当前构建，是运行时从容器(另一个项目)中加载。
加载远程模块被认为是异步操作。当使用远程模块时，这些异步操作将被放置在远程模块和入口之间的下一个 chunk 的加载操作中，如果没有 chunk 加载操作，就不能使用远程模块。
> 注：
chunk就是打包后的代码块。
> chunk是webpack打包过程中，一堆module的集合，我们知道webpack的打包是从一个入口文件开始，也可以说是入口模块，入口模块引用这其他模块，模块再引用模，webpack通过引用关系逐个打包模块，这些module就形成了一个chunk。
> 如果我们有多个入口文件，可能会产出多条打包路径，一条路径就会形成一个Chunk。出了入口entry会产生Chunk。

chunk 的加载操作通常是通过调用 import() 实现的，但也支持像 require.ensure 或 require([...]) 之类的旧语法。
容器是由容器入口创建的，该入口暴露了对特定模块的异步访问。暴露的访问分为两个步骤：

1. 加载模块（异步的）
2. 执行模块（同步的）

加载模块将在 chunk 加载期间完成，执行模块将在与其他（本地和远程）的模块交错执行期间完成，这样一来，执行顺序不受模块从本地转换为远程或从远程转为本地的影响。
容器可以嵌套使用，容器可以使用来自其他容器的模块。容器之间也可以循环依赖。
**应用场景**
**1. 每个页面单独构建**
单页应用的每个页面都是在单独的构建中从容器暴露出来的，主体应用程序(application shell)也是独立构建，会将所有页面作为远程模块来引用。
通过这种方式，可以单独部署每个页面，在更新路由或添加新路由时部署主体应用程序。主体应用程序将常用库定义为共享模块，以避免在页面构建中出现重复。
**2. 将组件库作为容器**
许多应用程序共享一个通用的组件库，可以将其构建成暴露所有组件的容器。每个应用程序使用来自组件库容器的组件。
可以单独部署对组件库的更改，而不需要重新部署所有应用程序。应用程序自动使用组件库的最新版本。
> 注：
这可以解决很多问题，比如我一个重量级项目打包起来很慢，我是不是可以使用模块联邦，将项目分成几部分，独立打包独立部署。
> 或者说，我的组件库是不是可以做成可插拔的效果。
> 如果有公共平台，我们做二次开发是不是也可以用这个方法来做架构。

3. 动态远程容器
该容器接口支持 get 和 init 方法。 init 是一个兼容 async 的方法，调用时，只含有一个参数：共享作用域对象(shared scope object)。此对象在远程容器中用作共享作用域，并由 host 提供的模块填充。 可以利用它在运行时动态地将远程容器连接到 host 容器。
[详细介绍](https://juejin.cn/post/7198041700563370041#heading-0)
**区别：**
1. qiankun是一种微前端技术，而模块联邦是一种模块化开发技术。
2. qiankun以单页应用为核心，可以将多个子应用作为独立的SPA运行；
而模块联邦则以多个模块作为核心，可以将多个子应用作为多个模块运行。
3. qiankun可以实现路由统一，数据共享；
而模块联邦则可以实现代码统一，数据隔离。
4. qiankun的优势在于可以实现跨应用的路由跳转和数据共享；
而模块联邦的优势在于可以实现代码的复用和数据的隔离。
